<!-- a single page, single page app -->
<html>
    <head>
        <title id="windowTitle">palettify</title>
    </head>
    <body>
        <h1 id='mainTitle'>palettify</h1>
        <p>
            create beautiful palettes powered by 
            <a href="https://noopschallenge.com/challenges/hexbot">hexbot</a>
        </p>
        <div id='paletteView'>

        </div>
    </body>
</html>
<style>
    html { text-transform: uppercase; font-family: sans-serif; font-weight: bold }
    html { line-height: 1.5; letter-spacing: .2em; }
    .paletteColor { display: inline-block; width:4rem; height:4rem; }
</style>
<script>

    'use strict';
    console.log("Let's see how far we can push this!!!!!");
    setTimeout(main);

    const projectTitle = 'palettify';

    let title = null;
    let palette = [];
    let somethingWentWrong = false;
    let isLoading = false;
    let loadingAnimationTimeout = null;
    let loadingAnimationFrame = 0;

    async function main(){
        const colors = await getRandomColors(16);
        setPalette(sortColors(colors));
    }

    function setPalette(value){
        palette = value;
        onPaletteChanged();
    }

    function onPaletteChanged(){
        renderPaletteView();
    }

    async function getRandomColors(count){
        setIsLoading(true);
        try{
            return await getRandomColorsFromHexbot(count);
        }
        catch (error){
            console.error(error);
            setSomethingWentWrong(true);
            return [];
        }
        finally{
            setIsLoading(false);
        }
    }

    async function getRandomColorsFromHexbot(count){
        let url = 'https://api.noopschallenge.com/hexbot';
        if (count != null){
            url += '?count=' + encodeURIComponent(count);
        }
        const response = await fetch(url);
        const json = await response.json();
        const colors = decodeHexbotResponse(json);
        return colors;
    }


    function setIsLoading(state){
        if (isLoading != state){
            isLoading = state;
            isLoadingChanged();
        }
    }

    function setSomethingWentWrong(state){
        if (somethingWentWrong == state) return;
        somethingWentWrong = state;
        renderTitle();
    }

    function isLoadingChanged(){
        renderTitle();
    }

    function renderTitle(){
        let content = projectTitle;
        if (isLoading){
            content += ' is working';
            for (let i=0;i< loadingAnimationFrame; i++){
                content += '.';
            }
            loadingAnimationTimeout = setTimeout(() => {
                loadingAnimationFrame++;
                isLoadingChanged();
            }, 10);
        } 
        else 
        {
            loadingAnimationFrame = 0;
        }
        if (somethingWentWrong){
            content += ' failed, check console';
        }
        setTitle(content);
    }

    function sortColors(unsorted){
        let colors = sortColorsByLuminance(unsorted);
        for (let i=0; i<100; i++){
            colors = arrangeColorsByMinimizingDistance(colors);
        }
        return colors;
    }

    function sortColorsByLuminance(unsorted){
        const colors = unsorted.slice();
        colors.sort((a,b) => Math.sign(a[0]*2+a[1]*3+a[2]-b[0]*2-b[1]*3-b[2]));
        return colors;
    }

    function arrangeColorsByMinimizingDistance(unsorted){
        const colors = unsorted.slice();
        function distanceAt(color, index) {
            let distance = 0;
            if (index < colors.length-1) { 
                distance += manhattanDistance(colors[index], colors[index+1]);
            }
            if (index > 0) { 
                distance += manhattanDistance(colors[index], colors[index-1]); 
            }
            return distance;
        }

        for (let i=1; i<colors.length-1; i++){
            for (let j=1; j<colors.length-1; j++){
                const ith = colors[i];
                const jth = colors[j];
                const initialDistance = 
                    distanceAt(ith, i) + distanceAt(jth, j);
                const distanceAfterSwap = 
                    distanceAt(jth, i) + distanceAt(ith, j);

                if (initialDistance > distanceAfterSwap){
                    colors[j] = ith;
                    colors[i] = jth;
                }
            }
        }
        return colors;
    }

    function eucledianDistance(a,b){
        return Math.sqrt(
            Math.pow(a[0]-b[0],2),
            Math.pow(a[1]-b[1],2),
            Math.pow(a[2]-b[2],2));
    }

    function manhattanDistance(a,b){
        return Math.abs(a[0]-b[0]);
            +  Math.abs(a[1]-b[1]);
            +  Math.abs(a[2]-b[2]);
    }

    function setTitle(stringValue){
        if (title === stringValue) return;
        title = stringValue;
        mainTitle.textContent = title;
        windowTitle.textContent = title;
    }

    function renderPaletteView(){
        paletteView.innerHTML = '';
        for (let [r,g,b] of palette){
            paletteView.appendChild(render('div', {
                className: 'paletteColor',
                style: `background: rgb(${r},${g},${b})`
            }));
        }
    }

    const render = (tag, props) => {
        const element = document.createElement(tag);
        for (let key in props){
            element[key] = props[key];
        }
        return element;
    }

    const decodeHexbotResponse = ({ colors }) => 
        colors.map(({value}) => hexToRgb(value));

    const hexToRgb = (hex) => hex.match(/[0-9A-F]{2}/g).map(hexToInt);

    const hexToInt = (hex) => Number.parseInt(hex, 16);

</script>